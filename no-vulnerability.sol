pragma solidity ^0.4.24;

contract Fundraiser {
    mapping(address=>uint) balances;
    event LogInt(string, uint);

    function withdrawCoins(){
        uint withdrawAmount = balances[msg.sender];
        balances[msg.sender] = 0;
        Wallet wallet = Wallet(msg.sender);
        wallet.payout.value(withdrawAmount)();
    }

    function getBalance() constant returns (uint) {
        emit LogInt("fundraiser-getBalance", address(this).balance);
        return address(this).balance;
    }

    function contribute() payable {
        emit LogInt("fundraiser-contribute", balances[msg.sender]);
        balances[msg.sender] += msg.value;
    }

    function() payable {
        emit LogInt("fundraiser-fallback", 0);
    }
}

contract Wallet {

    Fundraiser fundraiser;
    uint recursion = 20;
    event LogInt(string, uint);

    constructor(address fundraiserAddress) {
        emit LogInt("Wallet-constructor", 0);
        fundraiser = Fundraiser(fundraiserAddress);
    }

    function contribute(uint amount) {
        emit LogInt("Wallet-contribute", this.getBalance());
        fundraiser.contribute.value(amount)();
    }

    function withdraw(){
        emit LogInt("Wallet-withdraw", this.getBalance());
        fundraiser.withdrawCoins();
    }

    function getBalance() constant returns (uint) {
        return address(this).balance;
    }

    function payout() payable {
        if(recursion>0){
            emit LogInt("Wallet-payout-recursion", recursion);
            emit LogInt("Wallet-payout-getBalance", this.getBalance());
            recursion--;
            fundraiser.withdrawCoins();
        }

    }

    function() payable {
        emit LogInt("Wallet-fallback", this.getBalance());
    }
}
